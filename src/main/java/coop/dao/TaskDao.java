package coop.dao;

import java.util.*;

import coop.model.*;
import org.hibernate.Hibernate;
import org.hibernate.HibernateException;
import org.hibernate.Session;
import org.hibernate.Transaction;
import org.hibernate.query.Query;

/**
 * The TaskDao class is a Data Access Object for abstracting out the CRUD operations on Task
 * objects.
 */
public class TaskDao extends HibernateDao {

    /**
     * Inserts a task object into the database. If this operation succeeds, the taskID field of the
     * task parameter is filled out with the ID auto-generated by the database.
     *
     * This is the C in CRUD.
     *
     * @param task the task model to be created
     * @return true if the task was inserted into the database without any errors
     */
    public boolean insertTask(Task task) {
        Session session = sessionFactory.openSession();
        Transaction insertTaskTransaction = null;
        boolean success;

        try {
            insertTaskTransaction = session.beginTransaction();
            session.persist(task);
            insertTaskTransaction.commit();
            success = true;
        } catch (HibernateException e) {
            if (insertTaskTransaction != null) {
                insertTaskTransaction.rollback();
            }

            success = false;
            e.printStackTrace();
        } finally {
            session.close();
        }

        return success;
    }

    /**
     * Finds the Task corresponding to the given taskID in the database.
     *
     * This is the R in CRUD.
     *
     * @param taskID the ID of the task object you wish to retrieve
     * @return the Task corresponding to the given taskID, or null if no such task exists in the
     *         database
     */
    public Task getTask(Integer taskID) {
        return getTask(taskID, false);
    }

    /**
     * Finds the Task corresponding to the given taskID in the database.
     *
     * @param taskID
     * @param initialize When true, also initialize the boards and users. This is expensive, so
     *        only do it when you need those.
     * @return
     */
    public Task getTask(Integer taskID, boolean initialize) {
        Session session = sessionFactory.openSession();
        Transaction getTaskTransaction = null;
        Task task;

        try {
            getTaskTransaction = session.beginTransaction();
            task = session.find(Task.class, taskID);

            if (initialize && task != null) {
                Hibernate.initialize(task.getBoard());
                Hibernate.initialize(task.getOwners());
            }

            getTaskTransaction.commit();
        } catch (HibernateException e) {
            task = null;
            e.printStackTrace();
        } finally {
            session.close();
        }

        return task;
    }

    /**
     * Updates a task in the database with whatever changes were made to it.
     *
     * This is the U in CRUD.
     *
     * @param task the task that was updated
     * @return true if the given task was successfully updated in the database
     */
    public boolean updateTask(Task task) {
        Session session = sessionFactory.openSession();
        Transaction updateTaskTransaction = null;
        boolean success;

        try {
            updateTaskTransaction = session.beginTransaction();
            session.merge(task);
            updateTaskTransaction.commit();
            success = true;
        } catch (HibernateException e) {
            if (updateTaskTransaction != null) {
                updateTaskTransaction.rollback();
            }

            success = false;
            e.printStackTrace();
        } finally {
            session.close();
        }

        return success;
    }

    /**
     * Removes the given task from the database.
     *
     * This is the D in CRUD.
     *
     * @param task the task to remove
     * @return true if the given task was successfully deleted from the database.
     */
    public boolean deleteTask(Task task) {
        Session session = sessionFactory.openSession();
        Transaction deleteTaskTransaction = null;
        BoardDao boardDao = new BoardDao();
        boolean success;

        try {
            deleteTaskTransaction = session.beginTransaction();
            Board b = task.getBoard();
            b.removeTask(task);
            boardDao.update(b);
            session.remove(task);
            deleteTaskTransaction.commit();
            success = true;
        } catch (HibernateException e) {
            if (deleteTaskTransaction != null) {
                deleteTaskTransaction.rollback();
            }

            success = false;
            e.printStackTrace();
        } finally {
            session.close();
        }

        return success;
    }

    public ImpactedProjectFile getImpactedProjectFile(Integer impactedProjectFileId) {
        Session session = sessionFactory.openSession();
        Transaction getImpactedProjectFileTransaction = null;
        ImpactedProjectFile impactedProjectFile;

        try {
            getImpactedProjectFileTransaction = session.beginTransaction();
            impactedProjectFile = session.find(ImpactedProjectFile.class, impactedProjectFileId);
            getImpactedProjectFileTransaction.commit();
        } catch (HibernateException e) {
            impactedProjectFile = null;
            e.printStackTrace();
        } finally {
            session.close();
        }

        return impactedProjectFile;
    }

    public ImpactedProjectFile getOrInsertImpactedProjectFile(String path, String branch) {
        Session session = sessionFactory.openSession();
        Transaction tx = null;
        ImpactedProjectFile impactedProjectFile = null;

        try {
            tx = session.beginTransaction();
            Query<ImpactedProjectFile> query = session.createQuery("FROM ImpactedProjectFile WHERE path = :p AND branch = :b", ImpactedProjectFile.class);
            query.setParameter("p", path);
            query.setParameter("b", branch);
            List<ImpactedProjectFile> impactedProjectFiles = query.list();
            if(impactedProjectFiles != null && impactedProjectFiles.size() == 1) {
                impactedProjectFile = impactedProjectFiles.get(0);
            } else if(impactedProjectFiles == null || impactedProjectFiles.isEmpty()) {
                impactedProjectFile = new ImpactedProjectFile(path, branch);
                impactedProjectFile.setImpactedProjectFileId((Integer) session.save(impactedProjectFile));
            }
            tx.commit();
        } catch (HibernateException e) {
            impactedProjectFile = null;
            e.printStackTrace();
        } finally {
            session.close();
        }

        return impactedProjectFile;
    }

    public boolean removeImpactedFileIfOrphan(ImpactedProjectFile impactedFile) {
        Session session = sessionFactory.openSession();
        Transaction tx = null;
        try {
            tx = session.beginTransaction();
            Query<Task> query = session.createQuery("FROM Task t WHERE :ipf IN elements(t.impactedFiles)", Task.class);
            query.setParameter("ipf", impactedFile);
            List<Task> referencingTasks = query.list();
            if(referencingTasks == null || referencingTasks.isEmpty()) {
                session.delete(impactedFile);
            }
            tx.commit();
        } catch (Exception e) {
            if (tx != null) {
                tx.rollback();
                return false;
            }
            e.printStackTrace();
        } finally {
            session.close();
        }
        return true;
    }

    public Map<String, Set<String>> getImpactedFileUsers(String impactedFilePath) {
        Map<String, Set<String>> impactedFileUsers = new HashMap<String, Set<String>>();
        Session session = sessionFactory.openSession();
        Transaction tx = null;

        try {
            tx = session.beginTransaction();
            Query<ImpactedProjectFile> getImpactedProjectFileQuery = session.createQuery("FROM ImpactedProjectFile WHERE path = :impactedFilePath", ImpactedProjectFile.class);
            getImpactedProjectFileQuery.setParameter("impactedFilePath", impactedFilePath);
            ImpactedProjectFile impactedProjectFile = getImpactedProjectFileQuery.getSingleResult();
            Query<Task> taskQuery = session.createQuery("FROM Task t WHERE :ipf IN elements(t.impactedFiles)", Task.class);
            taskQuery.setParameter("ipf", impactedProjectFile);
            List<Task> referencingTasks = taskQuery.list();

            Set<String> currentImpactedFileUsers = new TreeSet<String>();
            Set<String> previousImpactedFileUsers = new TreeSet<String>();

            for(Task t: referencingTasks) {
                if(t.getBoard().isActive()) {
                    for (User u : t.getOwners()) {
                        currentImpactedFileUsers.add(u.getFirstName() + " " + u.getLastName());
                    }
                } else {
                    for (User u : t.getOwners()) {
                        previousImpactedFileUsers.add(u.getFirstName() + " " + u.getLastName());
                    }
                }

            }
            previousImpactedFileUsers.removeAll(currentImpactedFileUsers);

            impactedFileUsers.put("current", currentImpactedFileUsers);
            impactedFileUsers.put("previous", previousImpactedFileUsers);

            tx.commit();
        } catch (HibernateException e) {
            e.printStackTrace();
        } finally {
            session.close();
        }

        return impactedFileUsers;
    }
}